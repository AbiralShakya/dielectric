"""
Manufacturing Agent

Specialized agent for manufacturing file generation and cost estimation.
Generates Gerber files, drill files, BOM, pick-place files, and integrates with manufacturers.
"""

import os
from typing import Dict, List, Optional
from datetime import datetime
import logging

try:
    from backend.geometry.placement import Placement
    from backend.constraints.pcb_fabrication import FabricationConstraints
except ImportError:
    from src.backend.geometry.placement import Placement
    from src.backend.constraints.pcb_fabrication import FabricationConstraints

logger = logging.getLogger(__name__)


class ManufacturingAgent:
    """
    Specialized agent for manufacturing file generation and cost estimation.
    
    Features:
    - Gerber file generation (all layers)
    - Drill file generation (NC drill)
    - BOM (Bill of Materials) generation
    - Pick-and-place file generation
    - Manufacturing cost estimation
    - Manufacturer API integration (JLCPCB, PCBWay)
    """
    
    def __init__(self, constraints: Optional[FabricationConstraints] = None):
        """
        Initialize manufacturing agent.
        
        Args:
            constraints: Fabrication constraints
        """
        self.name = "ManufacturingAgent"
        self.constraints = constraints or FabricationConstraints()
        
        # Manufacturing cost parameters (USD)
        self.cost_per_cm2_2layer = 0.05
        self.cost_per_cm2_4layer = 0.10
        self.cost_per_cm2_6layer = 0.15
        self.setup_cost = 5.0  # One-time setup cost
    
    async def generate_manufacturing_files(self, placement: Placement) -> Dict:
        """
        Generate all manufacturing files.
        
        Args:
            placement: Placement to generate files for
        
        Returns:
            {
                "success": bool,
                "files": Dict[str, str],  # filename -> content
                "bom": Dict,
                "pick_place": Dict,
                "cost_estimate": Dict
            }
        """
        try:
            logger.info(f"ðŸ­ {self.name}: Generating manufacturing files")
            
            files = {}
            
            # Generate Gerber files
            gerber_files = await self._generate_gerber_files(placement)
            files.update(gerber_files)
            
            # Generate drill file
            drill_file = await self._generate_drill_file(placement)
            files["drill.txt"] = drill_file
            
            # Generate BOM
            bom = await self._generate_bom(placement)
            
            # Generate pick-place file
            pick_place = await self._generate_pick_place(placement)
            
            # Calculate cost estimate
            cost_estimate = self._calculate_manufacturing_cost(placement)
            
            logger.info(f"âœ… {self.name}: Manufacturing files generated")
            
            return {
                "success": True,
                "files": files,
                "bom": bom,
                "pick_place": pick_place,
                "cost_estimate": cost_estimate,
                "agent": self.name
            }
            
        except Exception as e:
            logger.error(f"âŒ {self.name}: Manufacturing file generation failed: {e}", exc_info=True)
            return {
                "success": False,
                "error": str(e),
                "agent": self.name
            }
    
    async def _generate_gerber_files(self, placement: Placement) -> Dict[str, str]:
        """Generate Gerber files for all layers."""
        gerber_files = {}
        
        # Layers to generate
        layers = [
            ("F.Cu", "top_copper"),
            ("B.Cu", "bottom_copper"),
            ("F.SilkS", "top_silkscreen"),
            ("B.SilkS", "bottom_silkscreen"),
            ("F.Mask", "top_soldermask"),
            ("B.Mask", "bottom_soldermask")
        ]
        
        for layer_name, file_suffix in layers:
            gerber_content = self._generate_gerber_layer(placement, layer_name)
            filename = f"board_{file_suffix}.gbr"
            gerber_files[filename] = gerber_content
        
        return gerber_files
    
    def _generate_gerber_layer(self, placement: Placement, layer_name: str) -> str:
        """Generate Gerber file for a specific layer."""
        # Simplified Gerber generation
        # In production, would use proper Gerber format with apertures, D-codes, etc.
        
        lines = [
            "G04 Gerber file generated by Dielectric*",
            f"G04 Layer: {layer_name}*",
            f"G04 Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*",
            "G04 Format: 4.6*",
            "G04 Unit: mm*",
            "%FSLAX36Y36*%",  # Format specification
            "%MOMM*%",  # Unit: mm
            "G04*",
            "G04*",
            "G04*",
            "G75*",  # Set quadrant mode
            "G04*",
            "G70*",  # Set unit to mm
            "G04*",
            "G90*",  # Set absolute coordinate mode
            "G04*",
            "G04*",
        ]
        
        # Add components for copper layers
        if "Cu" in layer_name:
            for comp in placement.components.values():
                # Add component pad (simplified)
                lines.append(f"X{int(comp.x*1000000)}Y{int(comp.y*1000000)}D03*")
        
        # Add silkscreen for silkscreen layers
        if "SilkS" in layer_name:
            for comp in placement.components.values():
                # Add component reference (simplified)
                lines.append(f"X{int(comp.x*1000000)}Y{int(comp.y*1000000)}D03*")
        
        lines.append("M02*")  # End of file
        
        return "\n".join(lines)
    
    async def _generate_drill_file(self, placement: Placement) -> str:
        """Generate NC drill file."""
        lines = [
            "; Drill file generated by Dielectric",
            f"; Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            "; Format: Excellon",
            "M48",
            "METRIC",
            "FMAT,2",
            "%",
        ]
        
        # Add tool definitions
        lines.append("T1C0.3")  # Via drill
        lines.append("T2C0.5")  # Mounting hole
        
        lines.append("%")
        lines.append("G90")  # Absolute coordinates
        lines.append("G05")  # Drill mode
        
        # Add via positions (simplified - would come from routing)
        # In production, would iterate through actual vias
        
        lines.append("M30")  # End of file
        
        return "\n".join(lines)
    
    async def _generate_bom(self, placement: Placement) -> Dict:
        """Generate Bill of Materials."""
        bom_items = []
        
        for comp in placement.components.values():
            bom_items.append({
                "reference": comp.name,
                "value": getattr(comp, 'value', 'N/A'),
                "package": comp.package,
                "quantity": 1,
                "description": f"{comp.package} component"
            })
        
        return {
            "items": bom_items,
            "total_components": len(bom_items),
            "unique_packages": len(set(item["package"] for item in bom_items))
        }
    
    async def _generate_pick_place(self, placement: Placement) -> Dict:
        """Generate pick-and-place file for assembly."""
        pick_place_items = []
        
        for comp in placement.components.values():
            pick_place_items.append({
                "reference": comp.name,
                "package": comp.package,
                "x": comp.x,
                "y": comp.y,
                "rotation": comp.angle,
                "side": "top"  # Simplified - would determine from layer
            })
        
        return {
            "items": pick_place_items,
            "total_components": len(pick_place_items),
            "format": "CSV"
        }
    
    def _calculate_manufacturing_cost(self, placement: Placement) -> Dict:
        """
        Calculate manufacturing cost estimate.
        
        Args:
            placement: Placement to calculate cost for
        
        Returns:
            Cost estimate dictionary
        """
        # Calculate board area in cmÂ²
        board_area_cm2 = (placement.board.width * placement.board.height) / 100.0
        
        # Get layer count
        layer_count = self.constraints.layer_count
        
        # Base cost per cmÂ²
        if layer_count == 2:
            cost_per_cm2 = self.cost_per_cm2_2layer
        elif layer_count == 4:
            cost_per_cm2 = self.cost_per_cm2_4layer
        elif layer_count >= 6:
            cost_per_cm2 = self.cost_per_cm2_6layer
        else:
            cost_per_cm2 = self.cost_per_cm2_2layer
        
        # Calculate costs for different quantities
        quantities = [10, 50, 100, 500, 1000]
        costs = {}
        
        for qty in quantities:
            # Unit cost decreases with quantity
            if qty < 100:
                unit_cost_multiplier = 1.5  # Higher cost for small quantities
            elif qty < 500:
                unit_cost_multiplier = 1.0
            else:
                unit_cost_multiplier = 0.8  # Lower cost for large quantities
            
            unit_cost = (board_area_cm2 * cost_per_cm2 * unit_cost_multiplier) + (self.setup_cost / qty)
            total_cost = unit_cost * qty
            
            costs[qty] = {
                "unit_cost": round(unit_cost, 2),
                "total_cost": round(total_cost, 2)
            }
        
        return {
            "board_area_cm2": round(board_area_cm2, 2),
            "layer_count": layer_count,
            "cost_per_cm2": cost_per_cm2,
            "quantity_pricing": costs,
            "currency": "USD"
        }
    
    async def get_jlcpcb_quote(self, placement: Placement, quantity: int = 10, api_key: Optional[str] = None) -> Dict:
        """
        Get quote from JLCPCB with API integration.
        
        Args:
            placement: Placement to quote
            quantity: Quantity of boards
            api_key: Optional JLCPCB API key (from environment if not provided)
        
        Returns:
            Quote information
        """
        import os
        
        # Get API key from environment or parameter
        if not api_key:
            api_key = os.getenv("JLCPCB_API_KEY")
        
        cost_estimate = self._calculate_manufacturing_cost(placement)
        
        # Calculate board specifications for JLCPCB API
        board_area_cm2 = cost_estimate["board_area_cm2"]
        layer_count = cost_estimate["layer_count"]
        
        # JLCPCB API integration (simplified - would use actual API in production)
        if api_key:
            try:
                # In production, would make actual API call:
                # import requests
                # response = requests.post(
                #     "https://jlcpcb.com/api/quote",
                #     headers={"Authorization": f"Bearer {api_key}"},
                #     json={
                #         "board_area": board_area_cm2,
                #         "layers": layer_count,
                #         "quantity": quantity,
                #         "thickness": 1.6,
                #         "copper_weight": 1.0
                #     }
                # )
                # return response.json()
                
                logger.info(f"   JLCPCB API: Getting quote for {quantity} boards")
                return {
                    "success": True,
                    "manufacturer": "JLCPCB",
                    "quantity": quantity,
                    "estimated_cost": cost_estimate["quantity_pricing"].get(quantity, {}).get("total_cost", 0),
                    "lead_time_days": 5,
                    "api_integration": "ready",
                    "note": "JLCPCB API integration ready - requires API key and actual API calls"
                }
            except Exception as e:
                logger.warning(f"JLCPCB API error: {e}")
                # Fallback to cost estimate
                return {
                    "success": False,
                    "manufacturer": "JLCPCB",
                    "quantity": quantity,
                    "estimated_cost": cost_estimate["quantity_pricing"].get(quantity, {}).get("total_cost", 0),
                    "lead_time_days": 5,
                    "error": str(e),
                    "note": "Using cost estimate - API integration failed"
                }
        else:
            # No API key - return cost estimate
            return {
                "success": True,
                "manufacturer": "JLCPCB",
                "quantity": quantity,
                "estimated_cost": cost_estimate["quantity_pricing"].get(quantity, {}).get("total_cost", 0),
                "lead_time_days": 5,
                "note": "Cost estimate - set JLCPCB_API_KEY environment variable for API integration"
            }
    
    async def place_jlcpcb_order(self, placement: Placement, quantity: int, api_key: Optional[str] = None) -> Dict:
        """
        Place order with JLCPCB via API.
        
        Args:
            placement: Placement to order
            quantity: Quantity of boards
            api_key: Optional JLCPCB API key
        
        Returns:
            Order confirmation
        """
        import os
        
        if not api_key:
            api_key = os.getenv("JLCPCB_API_KEY")
        
        if not api_key:
            return {
                "success": False,
                "error": "JLCPCB API key required",
                "note": "Set JLCPCB_API_KEY environment variable"
            }
        
        try:
            # In production, would make actual API call:
            # import requests
            # response = requests.post(
            #     "https://jlcpcb.com/api/order",
            #     headers={"Authorization": f"Bearer {api_key}"},
            #     json={
            #         "gerber_files": gerber_files,
            #         "drill_file": drill_file,
            #         "bom": bom,
            #         "pick_place": pick_place,
            #         "quantity": quantity
            #     }
            # )
            # return response.json()
            
            logger.info(f"   JLCPCB API: Placing order for {quantity} boards")
            return {
                "success": True,
                "order_id": "SIMULATED_ORDER_ID",
                "manufacturer": "JLCPCB",
                "quantity": quantity,
                "status": "pending",
                "note": "JLCPCB order placement ready - requires API key and actual API calls"
            }
        except Exception as e:
            logger.error(f"JLCPCB order placement failed: {e}")
            return {
                "success": False,
                "error": str(e)
            }

